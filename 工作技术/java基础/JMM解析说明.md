java内存模型是一种虚拟机规范，屏蔽了硬件之间的差异，让各个平台达到一致的并发效果。在java1.5被重新修订。

### 1.基本类型和引用类型的差异

本地变量是基本类型时，本地变量一直在线程栈上。

本地变量是引用类型时，引用是在线程栈上，但是对象本身却在共享区的堆上。

### 2.硬件内存结构

现在的cpu的是多核的，每个CPU都有各自的寄存器和高速缓存器，每个CPU共享一块主内存。一个cpu在同一时间内只能处理一个线程，线程在处理程序时，需要把主内存的对象信息复制到各自的缓存器中，方便操作。

### 3.内存模型与实际内存的关系

内存模型和硬件模型不存在一对一的关系，他们各自都有一部分。java内存模型把实际的硬件模型进行了抽象化。

![](..\..\image\java内存模型.jpg)

### 4.解决存在的问题

- 内存缓存的信息不一致（可见性）

问题描述：存在一个共享变量，多个线程同时访问，每个线程都有独自的copy，当其中一个线程修改了共享变量的值，其他线程依旧访问的是修改前的值，也就是对修改后的值是不可见的。（一写多读的情况下）

解决方法：

①在共享变量被其中一个线程修改了之后，修改的值立即更新到主内存中去，当其他线程使用这个共享变量之前，先获取主内存中的最新值。

②使用synchronized关键字进行修饰，直接锁定变量。禁止指令重排序。

③使用final关键词，构造器没有把this传递出去。

- 指令重排造成的访问顺序不能保证正确（有序性）

问题描述：编译器优化时存在指令重排，指令级并行的重排，内存系统的重排。

解决方法：

①as-if-serial：不管如何重排，程序执行的结果不能改变

②happens-before：一个操作的执行结果对另外一个操作可见。

③特定类型的内存屏障：禁止特定类型的指令重排

- 写同步和原子性问题（原子性）

问题描述：共享变量被多个线程修改，就会出现冲突。（多写的情况下）

解决方法：

①原子性类：执行这些类时，操作过程不会出现被其他线程中断

②lock和同步关键字synchronized