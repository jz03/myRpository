### 1.懒汉模式

单例模式存在着变量共享的情况，所以存在着线程安全问题。饿汉模式由于主动创建，所以不存在线程安全问题。懒汉模式属于懒加载的情况，所以容易出现线程安全问题。

```java
package org.example.controller;

public class Client  {
    //volatile主要解决指令重排带来的线程安全问题
    private static volatile Client INSTENT;

    public static Client getClient(){
        //双重检验模式
        if(INSTENT == null){
            synchronized (Client.class){
                if (INSTENT == null) {
                    //模拟中间间隔时间，其中不释放锁
                    try {
                        Thread.sleep(10000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    INSTENT = new Client();
                }
            }
        }
        return INSTENT;
    }

    public static void main(String[] args) {
        for (int n = 0;n<10;n++){
            new Thread(new Runnable() {
                @Override
                public void run() {
                    Client client = getClient();
                    System.out.println(client);
                }
            }).start();
        }
    }

}
```

如果不进行线程同步，就会创建多种实例，而不是单例。

一般情况下，只需要双重检验同步就可以大部分情况下的线程安全问题。但是依旧存在一些在创建对象时出现指令重排带来的安全隐患，如果出现问题，表现为实例为默认空值。

创建对象的过程如下：

```shell
#创建一个空对象，已经分配内存，但是还没有进行对象的初始化，默认值不是null，只是完成了一半的初始化
new
#执行初始化方法（构造器），完成对象的实例化
invokespecial
#将对象和引用创建连接
astore
```

最后两步存在指令重排的现象，一旦出现指令重排，最外层的判断将会失效，误认为已经初始化完成，所以就返回了初始化一半的对象实例。volatile解决的就是指令重排的问题。