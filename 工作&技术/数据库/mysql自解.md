## 1.数据库设计的三大范式

- 确保每列都是原子性
- 表中的每列都和主键相关
- 表中的每列都和主键直接相关而不是间接相关

## 2.存储引擎

- innodb:提供了对数据库事务的支持，提供了行级锁和外键的约束。设计的目的是处理大数据的容量系统。

索引的实现方式是B+树索引，堆表。

更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。

- myiasm：不提供事务的支持，也不支持行级锁和外键约束。（默认引擎）

索引的实现方式是B+树索引，索引组织表。

以读写插入为主的应用程序，比如博客系统、新闻门户网站。

- memory：所有的数据都在内存中，数据的处理速度快，安全性不高。

## 3.索引

### 3.1.定义

索引是一种特殊文件，包含着对数据库表中数据记录的指针，索引也是一中数据结构，通常是b树和b+树。

- 优点

①可以加快数据的检索速度

②使用优化隐藏器，提高系统的性能

- 缺点

①在创建索引和维护索引时比较消耗时间，对数据的增加删除和修改的时候，索引也要进行相应的修改。

②索引也占用物理空间

### 3.2.索引使用的场景

- where条件
- order by
- join on

在where条件中很容易造成索引覆盖的情况。


### 3.3.索引的几种类型

- 主键索引：一张表只能有一个主键索引
- 唯一索引：数据列不允许重复，允许为NULL值，一张表可以有多个唯一索引

可以通过 `ALTER TABLE table_name ADD UNIQUE (column);` 创建唯一索引

可以通过 `ALTER TABLE table_name ADD UNIQUE (column1,column2);` 创建唯一组合索引

- 普通索引：基本的索引类型，没有唯一性的限制，允许为NULL值。

可以通过`ALTER TABLE table_name ADD INDEX index_name (column);`创建普通索引

可以通过`ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);`创建组合索引

- 全文索引：常见于搜索引擎

可以通过`ALTER TABLE table_name ADD FULLTEXT (column);`创建全文索引

### 3.4.索引的原理

把无序的查询变为有序的查询

- B+树算法（推荐使用）

它不仅可以被用在=,>,>=,<,<=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量。

```sql
-- 只要它的查询条件是一个不以通配符开头的常量
select * from user where name like 'jack%'; 
-- 如果一通配符开头，或者没有使用常量，则不会使用索引，例如： 
select * from user where name like '%jack'; 
```
- hash算法

被用在=,<=>（相当于=）操作符。无法进行范围查询。不支持排序。

#### 3.4.1.使用B+树的好处

B+树的内部节点只放置key，只有在叶子节点上存放key和value。B树在内部节点上存放的是key和value。B+树的叶子节点组成一个链表的形式，查询遍历的时间复杂度更小。

### 3.5.创建索引的原则

- 最左匹配原则，创建的索引字段尽可能的靠左，在SQL条件中优先执行前边的条件，如果前边的条件已经确定，后边的条件就不起作用。
- 字段频繁作为查询条件的，适合创建索引
- 字段更新频繁的，不适合创建索引
- 枚举字段，重复值比较多的列，不适合创建索引
- 定义为text、image和bit的数据类型的列不要建立索引

### 3.6.创建索引注意事项

- 所在列是非空字段

虽然索引允许字段为null的情况，但是null的比较运算比较复杂，对性能的影响较大

- 所在列的唯一值较多（离散度大）
- 所在列的内容较小

### 3.7.聚簇索引

相关的概念有非聚簇索引，覆盖索引，辅助索引

将数据存储和索引放在一块，在B+树的叶子节点上索引和行数据存放在一起。如果数据存储和索引分开，就是非聚簇索引，非聚簇索引容易出现回表查询，速度会变慢。

### 3.8.联合索引

通过多个字段建立一个索引，这种索引就是联合索引。使用联合索引要注意字段的顺序，否则索引不起作用。

## 4.事务

### 4.1.事务的四大特性

- 原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用。
- 一致性： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的
- 隔离性： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的
- 持久性：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

### 4.2.在并发事务中数据读取存在的问题

- 脏读：在一个事务执行完成之后，随后又执行了回滚，在这两个操作中间执行了数据读取
- 不可重复读：在两次查询中间执行了一次事务的数据更新操作
- 幻读：在一个事务的两次查询中，出现数据的条数不一致，和不可重复读情况相似

### 4.3.隔离级别

- READ-UNCOMMITTED(读取未提交)

最低的隔离级别，允许读取尚未提交的数据变更。三个问题都可能出现。

- READ-COMMITTED(读取已提交)

允许并发事务读取已提交的数据，可以阻止脏读。

读操作需要加共享锁，但是在语句执行完以后释放共享锁。

- REPEATABLE-READ(可重复读)  默认

对同一个字段多次读取结果都是一致的，除非被本身事务修改，其他事务修改不能改变这个一致性。可以阻止脏读和不可重复读。

读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。

- SERIALIZABLE(可串行化)

最高隔离级别。保证所有问题不能发生，但是执行效率比较慢。

## 5.数据库锁

### 5.1.锁的类型

- 共享锁

读锁，当用户读取时，对数据添加上共享锁，多个线程可以同时访问一个共享锁

- 排它锁

写锁，当用户写操作时，对数据添加上排它锁。只能允许一个线程访问。

- 行锁

InnoDB是基于索引来完成行锁。

- 页锁

- 表锁

- 悲观锁

假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制

一般多写的场景下用悲观锁就比较合适。

- 乐观锁

假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：一般会使用版本号机制或CAS算法实现。

乐观锁适用于写比较少的情况下（多读场景）