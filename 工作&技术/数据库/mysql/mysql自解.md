## 1.数据库设计的三大范式

- 确保每列都是原子性
- 表中的每列都和主键相关
- 表中的每列都和主键直接相关而不是间接相关

## 2.存储引擎

- innodb:提供了对数据库事务的支持，提供了行级锁和外键的约束。设计的目的是处理大数据的容量系统。

索引的实现方式是B+树索引，堆表。

更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。

- myiasm：不提供事务的支持，也不支持行级锁和外键约束。（默认引擎）

索引的实现方式是B+树索引，索引组织表。

以读写插入为主的应用程序，比如博客系统、新闻门户网站。

- memory：所有的数据都在内存中，数据的处理速度快，安全性不高。

## 3.索引

### 3.1.定义

索引是一种特殊文件，包含着对数据库表中数据记录的指针，索引也是一种数据结构，通常是b树和b+树。

- 优点

①可以加快数据的检索速度

②使用优化隐藏器，提高系统的性能

- 缺点

①在创建索引和维护索引时比较消耗时间，对数据的增加删除和修改的时候，索引也要进行相应的修改。

②索引也占用物理空间

### 3.2.索引使用的场景

- where条件
- order by
- join on

在where条件中很容易造成索引覆盖的情况。


### 3.3.索引的几种类型

- 主键索引：一张表只能有一个主键索引
- 唯一索引：数据列不允许重复，允许为NULL值，一张表可以有多个唯一索引

可以通过 `ALTER TABLE table_name ADD UNIQUE (column);` 创建唯一索引

可以通过 `ALTER TABLE table_name ADD UNIQUE (column1,column2);` 创建唯一组合索引

- 普通索引：基本的索引类型，没有唯一性的限制，允许为NULL值。

可以通过`ALTER TABLE table_name ADD INDEX index_name (column);`创建普通索引

可以通过`ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);`创建组合索引

- 全文索引：常见于搜索引擎

可以通过`ALTER TABLE table_name ADD FULLTEXT (column);`创建全文索引

### 3.4.索引的原理

把无序的查询变为有序的查询

- B+树算法（推荐使用）

它不仅可以被用在=,>,>=,<,<=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量。

```sql
-- 只要它的查询条件是一个不以通配符开头的常量
select * from user where name like 'jack%'; 
-- 如果一通配符开头，或者没有使用常量，则不会使用索引，例如： 
select * from user where name like '%jack'; 
```
- hash算法

被用在=,<=>（相当于=）操作符。无法进行范围查询。不支持排序。

#### 3.4.1.使用B+树的好处

B+树的内部节点只放置key，只有在叶子节点上存放key和value。B树在内部节点上存放的是key和value。B+树的叶子节点组成一个链表的形式，查询遍历的时间复杂度更小。

### 3.5.创建索引的原则

- 最左匹配原则，创建的索引字段尽可能的靠左，在SQL条件中优先执行前边的条件，如果前边的条件已经确定，后边的条件就不起作用。
- 字段频繁作为查询条件的，适合创建索引
- 字段更新频繁的，不适合创建索引
- 枚举字段，重复值比较多的列，不适合创建索引
- 定义为text、image和bit的数据类型的列不要建立索引

### 3.6.创建索引注意事项

- 所在列是非空字段

虽然索引允许字段为null的情况，但是null的比较运算比较复杂，对性能的影响较大

- 所在列的唯一值较多（离散度大）
- 所在列的内容较小

### 3.7.聚簇索引

相关的概念有非聚簇索引，辅助索引

覆盖索引:索引的数据覆盖了需要查询的所有数据

将数据存储和索引放在一块，在B+树的叶子节点上索引和行数据存放在一起。如果数据存储和索引分开，就是非聚簇索引，非聚簇索引容易出现回表查询，速度会变慢。

### 3.8.联合索引

通过多个字段建立一个索引，这种索引就是联合索引。使用联合索引要注意字段的顺序，否则索引不起作用。

## 4.事务

### 4.1.事务的四大特性

- 原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用。
- 一致性： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的
- 隔离性： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的
- 持久性：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

### 4.2.在并发事务中数据读取存在的问题

- 脏读：在一个事务执行完成之后，随后又执行了回滚，在这两个操作中间执行了数据读取
- 不可重复读：在两次查询中间执行了一次事务的数据更新操作
- 幻读：在一个事务的两次查询中，出现数据的条数不一致，和不可重复读情况相似

### 4.3.隔离级别

- READ-UNCOMMITTED(读取未提交)

最低的隔离级别，允许读取尚未提交的数据变更。三个问题都可能出现。

- READ-COMMITTED(读取已提交)

允许并发事务读取已提交的数据，可以阻止脏读。

读操作需要加共享锁，但是在语句执行完以后释放共享锁。

- REPEATABLE-READ(可重复读)  默认

对同一个字段多次读取结果都是一致的，除非被本身事务修改，其他事务修改不能改变这个一致性。可以阻止脏读和不可重复读。

读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。

- SERIALIZABLE(可串行化)

最高隔离级别。保证所有问题不能发生，但是执行效率比较慢。

## 5.数据库锁

### 5.1.锁的类型

- 共享锁

读锁，当用户读取时，对数据添加上共享锁，多个线程可以同时访问一个共享锁

- 排它锁

写锁，当用户写操作时，对数据添加上排它锁。只能允许一个线程访问。

- 行锁

InnoDB是基于索引来完成行锁。

- 页锁

- 表锁

- 悲观锁

假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制

一般多写的场景下用悲观锁就比较合适。

- 乐观锁

假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：一般会使用版本号机制或CAS算法实现。

乐观锁适用于写比较少的情况下（多读场景）

## 6.视图

主要目的是为了提高复杂SQL的复用性和操作的安全性。现在在web开发中很少使用视图，视图的功能被orm所替代。

对视图中的内容进行更新时，可以影响到基本表。如果视图是来自多个基本表时，不允许删除和新增数据。

复杂视图对性能不是很好，修改也有许多的不方便。

## 7.存储过程和函数

### 7.1.两者之间的区别

存储过程的定位是完成一段业务逻辑，函数的定位是实现某一功能，相对于存储过程来说粒度更小，函数可以在SQL语句中调用，而存储过程只能用固定的语法调用，不能被其他SQL直接调用。

### 7.1.优点和缺点

优点是由于是预编译好的SQL，执行速度快，安全性高，可以重复使用。

缺点是在项目需求发生变化，后期的持续维护的时候变得几乎是不可能的一件事。

### 7.2.触发器

由事件驱动的一种特殊存储过程，当触发这个事件时，就会自动自行触发器中的代码。

触发器主要有6种，增、删、改的前后。

## 8.SQL语句

### 8.1.关联查询

- 内连接（只显示满足条件的数据记录）
  - 等值连接 ON A.id=B.id
  - 不等值连接 ON A.id > B.id
  - 自连接 SELECT * FROM A T1 INNER JOIN A T2 ON T1.id=T2.pid

- 外连接（对于没有匹配到的记录显示为null）
  - 左连接：以左边的表为主，进行表之间的连接，左表不能为null，右表可以为null
  - 右连接：和左连接的连接逻辑相同

- 联合查询（UNION与UNION ALL）

如果使用UNION ALL，不会合并重复的记录行。效率 UNION 高于 UNION ALL。

主要是把两个查询出的结果合并在一起。

- 全连接

mysql不支持，但是可以通过其他方式实现

### 8.2.exists和in

exists返回的结果是布尔值，in是包含关系。

子查询表大的用exists，子查询表小的用in。

无论那个表大，用not exists都比not in要快。

## 9.SQL优化

### 9.1.大数据表如何优化

- 使用索引
- 添加缓存，redis
- 读写分离
- 垂直拆分，分布式系统
- 水平拆分，将一张大表拆成多张表

### 9.2.分页查询优化

```sql
#每页大小为10，当前是第二页
select * from user limit 1,10;
```

尽量使用索引，减少导入的数据

### 9.3.where条件的优化

- 尽量使用索引，避免全表扫描
- 尽量避免对字段进行null判断，这样会让引擎放弃使用索引
- 尽量避免在 where 子句中使用!=或<>操作符
- 尽量避免在 where 子句中使用or 来连接条件
- in 和 not in 也要慎用，否则会导致全表扫描
- 模糊查询也容易放弃索引
- 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描
- 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描
- 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引

### 9.4.主从库

主从库主要对应的是数据读写分离。涉及到读和写找到指定的数据源。

实现方案：

使用AbstractRoutingDataSource+aop+annotation在dao层决定数据源。
如果采用了mybatis， 可以将读写分离放在ORM层，比如mybatis可以通过mybatis plugin拦截sql语句，所有的insert/update/delete都访问master库，所有的select 都访问salve库，这样对于dao层都是透明。 plugin实现时可以通过注解或者分析语句是读写方法来选定主从库。不过这样依然有一个问题， 也就是不支持事务， 所以我们还需要重写一下DataSourceTransactionManager， 将read-only的事务扔进读库， 其余的有读有写的扔进写库。
