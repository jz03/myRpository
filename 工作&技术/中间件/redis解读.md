## 1.定义

是用C语言编写的开源高性能非关系型的键值对数据库。键的类型只能是字符串，值的类型有五种（字符串，列表，集合，散列表，有序集合）。

redis的数据是存在内存中的，所以读写速度比较快。被广泛用在了缓存方向，经常用在分布式锁。

支持事务，持久化等。

### 1.1优缺点

**优点：**

- 读写性能优异， Redis能读的速度是110000次/s，写的速度是81000次/s。
- 支持数据持久化，支持aof和rdb两种方式的持久化
- 支持事务，所有操作都是原子性的，采用的单线程
- 数据结构丰富
- 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离

**缺点：**

- 收到物理内存的限制，不能用作海量数据的高性能读写。
- 不具备自动容错和恢复功能
- 难以支持在线扩容

### 1.2本地缓存和分布式缓存

缓存分为本地缓存和分布式缓存，本地缓存常见的是java中的map容器和guava缓存，本地缓存是每一个实例都有各自的缓存，实例之间的缓存不能共用，这些缓存不存在一致性。

分布式缓存是指各个实例共用一个缓存，这种缓存就是分布式缓存，缓存具有一致性，redis和memcached 都是分布式缓存。

## 2.数据类型

主要有5中类型，string、list、set、有序set、hash（唯一值）

### 3.持久化

持久化就是把缓存的数据写到磁盘当中去。持久化有两种机制。

### 3.1. rdb（默认）

是redis默认的方式，按照一定的时间将内存中的数据以快照的方式保存到磁盘当中，产生的数据文件是dump.rdb。这个周期时间可以配置。

### 3.2.aof

将redis执行的每次写命令记录到单独的日志文件中，redis重启的时候从这些日志文件中恢复数据。

在两个持久化机制中优先使用aof的恢复还原机制。因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。

## 3.内存相关

### 3.1.如何保证redis中的数据时热点数据

redis内存数据达到一定的限度时，就会实行数据淘汰策略。

### 3.2.内存淘汰策略

#### 3.2.1.全局的键空间选择性移除

- noeviction：新写入操作写入报错
- allkeys-lru：移除最近最少用的key
- allkeys-random：随机移除几个key

#### 3.2.2.设置过期的键选择性移除

- volatile-lru：在设置了过期时间的键空间中，移除最近最少使用的key
- volatile-random：在设置了过期时间的键空间中，随机移除某个key
- volatile-ttl：在设置了过期时间的键空间中，有更早过期时间的key优先移除

## 4.redis事务

一次性、顺序性、排他性的执行一个队列中的一系列命令。

### 4.1.三个阶段

1. 事务开始MULTI
2. 命令入队
3. 事务执行EXEC

事务执行过程中，如果收到其他指令请求，就会把指令先放进队列中。

### 4.2.事务管理

- 原子性（不支持）
- 一致性
- 隔离性：一个事务的执行不影响其他事务

Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断。

- 持久性：一个事务一旦提交，对数据库的影响是永久性的（不支持）

## 5.集群方案

### 5.1.哨兵（sentinel）模式

哨兵模式主要是进行监控，根据监控的信息进行相应的配置调整等操作。

原理：哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。

作用：①通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。②当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。

主要的功能有：集群监控，消息通知，故障转移，配置中心处理。

哨兵至少有3个实例，来保证自己的健壮性。



## 6.缓存

### 6.1.缓存雪崩

在同一时间大部分缓存失效，后面的请求都落向数据库上，造成数据库在短时间内崩掉。

### 6.2.缓存穿透

缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。

### 6.3.缓存击穿

缓存中没有该数据，数据库中有该数据，就在此时用户量同时并发过多，造成数据库在一瞬间压力过大而崩掉。

### 6.4.缓存预热

系统上线后，先缓存一些常用的热点数据。

### 6.5.缓存降级

当一些核心服务由于访问量降低，需要把缓存级别给降下来，可以避免一些缓存雪崩的问题。



------------------------------------------------------

整体看下来，在集群和分布式锁的部分简直不能理解，为何一个主要用来缓存的数据库竟然能够做这么的事，看完之后头蒙。

