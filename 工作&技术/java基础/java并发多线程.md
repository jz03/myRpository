# 1.三个要素

- 原子性：一个操作是不可中断的
- 可见性：一个线程对共享变量的修改，其他线程也能看到
- 有序性：编译器对指令进行优化重排，会对多线程程序执行带来问题

这三个要素是并发编程面对的问题和挑战。不能有这个保证将会带来数据的不安全，不可靠。

其中涉及到编译器，内存模型，虚拟机里边的原理。

## 2.基本的线程机制

### 2.1.定义任务

任何一个线程都可以驱动另外一个线程。

- Runnable接口的实现

主要来定义任务，这个任务没有返回值，如果想有线程能力，必须附着在一个线程上。自身没有线程能力。

- Thread类

主要用来驱动任务。自身不做任何操作。

起一个线程，并能执行这些任务，只能处理Runnable实现的任务，不能启动处理有返回值的任务。

- Executor执行器

用来管理异步任务的执行。里边是使用**线程池**来实现的各种执行器。

```java
//典型使用方式
ExecutorService executorService = Executors.newCachedThreadPool();
for (int i = 0; i < 5; i++) {
    executorService.execute(new LiftOff());
}
//关闭向执行器中添加新的任务
executorService.shutdown();
```

- Callable接口：有返回值的任务

只能用执行器来驱动有返回值的任务，代码实现和没有返回值的要复杂的多。

### 2.2.优先级

优先级只是代表线程被执行的频率，与多数操作系统都不能映射的很好。

### 2.3.后台线程

只要是任何一个线程还在运行，后台线程就不会终止。

代码实现：

```java
Thread thread = new Thread(new LiftOff());
//必须在开始之前设置
thread.setDaemon(true);
thread.start();
```

在后台线程的任务中的线程也是后台线程。

后台线程在不执行finally子句就会终止run（）方法。

### 2.4.线程之间的join操作

在B线程加入到A线程的时候，当B运行的时候，A是阻塞的，当B运行结束的时候，A才能继续执行。

也可以在join操作的时候增加时间限制。

### 2.5.异常处理

任务中出现异常将不会被调用者捕获，所以就在Thread.UncaughtExceptionHandler接口进行处理这些无法捕获的异常。

## 3.共享受限资源

在共享受限资源中，多线程里边充满了易变性和不稳定性。

### 3.1.锁

对象锁，类锁，方法上的锁也是对整个对象加锁。

不要以为原子操作就可以放弃同步，这样做是天真可笑的想法。

### 3.2.volatile

保证了可视性。

原子操作不必刷新到主内存上，所以特别注意他的可视性。

变量的值依赖于其他的值，或者受到其他域的值限制，volatile都是无法工作的

修饰的域就会在编译阶段不被优化。也就保证了程序的有序性。

### 3.3.本地线程存储

ThreadLocal本地线程变量实现了各个线程的存储，每个互不干扰，只是代码上的共享，在内容上没有实现共享，所以不会产生竞争和线程安全问题。

## 4.任务的终结

### 1.在任务阻塞的时候终结

终止正在阻塞的线程时，需要清理资源。

通过executor执行器来中断，只能中断普通的sleep线程。

- sleep造成的阻塞
通过executor执行器来中断

```java
Future<?> submit = executorService.submit(liftOff);
submit.cancel(true);
```

- IO文件读写造成的阻塞

通过关闭资源流来实现中断阻塞的线程。

- 等待其他线程造成的阻塞

可以使用重用锁，能够在被阻塞的程序中被中断。

## 5.线程之间的协作

主要使用的是wait和notify两个方法。

sleep（）造成阻塞时，没有释放锁。

在使用wait和notify两个方法时，必须要获取同步对象锁，否则程序执行的时候就会出现异常。

通常使用BlockingQueue队列来代替wait和notify的实现，这样的编码更加的方便安全。