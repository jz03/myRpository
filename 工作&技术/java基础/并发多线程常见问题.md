### 1.sleep方法和yield方法的区别

   - sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会，**自己在这段时间之内不能被执行**；yield()方法只会给相同优先级或更高优先级的线程以运行的机会，**自己本身也有可能被执行**；两者不会使当前线程出现阻塞。
   - 线程执行sleep()方法后转入TIMED_WAITING状态，而执行yield()方法后转入就绪（ready）状态；
   - sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；
   - sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。

### 2.并发为何需要同步

一个变量或对象被多个线程同时使用时就会出现冲突，为了解决这个矛盾需要进行一个一个的来访问，这就需要加锁，一个一个访问之后变量或对象中的内容会出现改变，这就需要数据等内容的同步，此时同步的问题就来了。

### 3.原子性和可见性

原子性是一个操作是不可分割的，在多线程的情况下，其他线程不能打断这个操作的完成，但是对于这个操作所做的内容修改，多线程就会出现读取错误的情况（可能读取到的是临时值）。虽然一个原子动作则需要进行加锁来保证其中的一致性。

可见性是一个值的修改，其他访问的线程内能够及时的读取到最新的修改。

### 4.CAS

