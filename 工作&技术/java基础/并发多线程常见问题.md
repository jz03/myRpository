### 1.sleep方法和yield方法的区别

   - sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会，**自己在这段时间之内不能被执行**；yield()方法只会给相同优先级或更高优先级的线程以运行的机会，**自己本身也有可能被执行**；两者不会使当前线程出现阻塞。
   - 线程执行sleep()方法后转入TIMED_WAITING状态，而执行yield()方法后转入就绪（ready）状态；
   - sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；
   - sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。

### 2.并发为何需要同步

一个变量或对象被多个线程同时使用时就会出现冲突，为了解决这个矛盾需要进行一个一个的来访问，这就需要加锁，一个一个访问之后变量或对象中的内容会出现改变，这就需要数据等内容的同步，此时同步的问题就来了。

### 3.原子性和可见性

原子性是一个操作是不可分割的，在多线程的情况下，其他线程不能打断这个操作的完成，但是对于这个操作所做的内容修改，多线程就会出现读取错误的情况（可能读取到的是临时值）。虽然一个原子动作则需要进行加锁来保证其中的一致性。

可见性是一个值的修改，其他访问的线程内能够及时的读取到最新的修改。

### 4.CAS

CAS的操作就是比较之后进行设置，整个过程没有使用同步锁。在jdk中的Unsafe类中，一般情况是不使用这个类，这个一般在容器中使用。

只是减少了同步加锁的范围，把出现问题的地方进行同步，其他地方就不用实行同步操作，这个可以提高并发的性能。

Unsafe类中的方法一般是CPU的原生指令，不能被打断。

- 存在的问题

  存在ABA的问题，可以通过版本号进行控制，jdk中使用的类是AtomicStampedReference来解决。

  循环可能能长，给CPU带来很大的开销

  只能保证一个变量的原子性

