JVM包括类加载子系统、**运行时数据区域**、执行引擎（即时编译器、垃圾回收器）、本地库接口。

### 1.内存结构（运行时数据区域）
- **metaspace（元数据区，永久区,方法区）**线程间共享

这个本是堆的一部分，只是属于永久区。在不同的java版本中存在区别

类信息、常量、静态变量、即时编译后的代码。

在java11是可以设置大小，在java8以下内存分配是固定的，容易出现内存溢出。

- **heap（堆区）**线程间共享

对象实例、静态的对象。存在新生代区，老年代区。

- **JVM Stacks（虚拟机栈）**

用于存储局部变量表、操作数栈、动态链接、方法出口等

各线程栈使用

- Native Method Stacks(本地方法栈)

主要提供调用本地方法

- program counter register(程序计数器)	

主要用来保证代码的执行顺序，不能出现混乱。

### 2.创建对象的过程

①查看现有的元数据区中是否存在相同的类信息，如果没有，加载对应的类信息

②给对象分配内存，主要是看内存是否规整，进行相应的内存分配方式。

③处理并发的情况

④初始化对象

### 3.内存溢出（OOM）

**内存泄露**积累过多就会造成内存溢出

长生命周期的对象持有短生命周期对象的引用，就会容易造成内存泄露。

### 4.垃圾回收器（GC）

在一般情况下，gc不会执行，大部分是在堆内存不足的时候执行gc。通常作为一个单独的低级别的线程运行。大概有8种垃圾回收器，每个垃圾回收器对应的算法和位置而不同。

- 正常情况下，永久代不会发生垃圾回收，但是在内存满或者超过了临界值，就会触发“完全垃圾回收”

- 垃圾回收有哪些算法

  ①标记-清除

  效率不高，产生大量不连续的内存碎片

  ②复制

  内存使用率不高，只有原来的一半

  ③标记整理

  标记无用的对象，把活的对象整理到一块，然后清理边界以外的对象

  ④分代

  将对象根据存活周期划分为不同的区域，新生代用复制的方式，老年代用标记整理的方式。

  不同代之间的内存大小存在一定的比例大小关系。

### 5.类加载器

类加载器的执行顺序是双亲委派模型，尽量用级别比较高的类加载器。

- 启动类加载器：加载java的核心类库
- 扩展类加载器：加载java的扩展类库
- 系统类加载器：加载普通开发的类
- 用户自定义加载器

#### 5.1.类的加载过程

①加载：查找路径找到相应的class文件

②验证：验证class文件的正确性

③准备：给静态变量进行分配空间

④解析：将类中的内容配置给指定的内存中

⑤初始化：对静态能量和静态代码进行初始化

### 6.调优

- 常见的工具

jconsole：用于对 JVM 中的内存、线程和类等进行监控，能够看到堆中的各代使用情况。

jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。

- 参数

-Xms2g  -Xms2g堆内存分配的大小

-XX:NewRatio=4 -XX:SurvivorRatio=8 设置堆内存中各代所占比例的设置

–XX:+UseParNewGC 设置合适的垃圾回收器

-XX:+PrintGC 开启打印gc执行的日志