JVM包括类加载子系统、**运行时数据区域**、执行引擎（即时编译器、垃圾回收器）、本地库接口。

### 1.内存结构（运行时数据区域）
- **metaspace（元数据区，方法区）**线程间共享

类信息、常量、静态变量、即时编译后的代码

- **heap（堆区）**线程间共享

对象实例、静态的对象。存在新生代区，老年代区。

- **JVM Stacks（虚拟机栈）**

用于存储局部变量表、操作数栈、动态链接、方法出口等

- Native Method Stacks(本地方法栈)

主要提供调用本地方法

- program counter register(程序计数器)

主要用来保证代码的执行顺序，不能出现混乱。

### 2.创建对象的过程

①查看现有的元数据区中是否存在相同的类信息，如果没有，加载对应的类信息

②给对象分配内存，主要是看内存是否规整，进行相应的内存分配方式。

③处理并发的情况

④初始化对象

### 3.内存溢出（OOM）

**内存泄露**积累过多就会造成内存溢出

长生命周期的对象持有短生命周期对象的引用，就会容易造成内存泄露。

### 4.垃圾回收器（GC）

在一般情况下，gc不会执行，大部分是在堆内存不足的时候执行gc。通常作为一个单独的低级别的线程运行。大概有8种垃圾回收器，每个垃圾回收器对应的算法和位置而不同。

- 正常情况下，永久代不会发生垃圾回收，但是在内存满或者超过了临界值，就会触发“完全垃圾回收”

- 垃圾回收有哪些算法

  ①标记-清除

  效率不高，产生大量不连续的内存碎片

  ②复制

  内存使用率不高，只有原来的一半

  ③标记整理

  标记无用的对象，把活的对象整理到一块，然后清理边界以外的对象

  ④分代

  将对象根据存活周期划分为不同的区域，新生代用复制的方式，老年代用标记整理的方式。

  不同代之间的内存大小存在一定的比例大小关系。

