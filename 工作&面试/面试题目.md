### 面试题目

#### 1.多线程创建有几种方式，都有哪些？

3种，Thread类的继承实现、Runable接口的实现、Callable接口的实现（有返回值，可以抛出异常）

#### 2.多个线程中一个主线程，如何保证主线程在其他子线成跑完？

CountDownLatch类用来计数，当线程都执行完了之后，在执行主线程剩余的部分

#### 3.如何才能不产生死锁？

#### 4.mybatis如何开启二级缓存？

#### 5.OOM的几种类型？

元数据区和堆区出现OOM，本地方法栈和虚拟机栈出现的StarkOverFlower

#### 6.单例模式

主动创建单例（饿汉），被动创建单例（懒汉，常用，容易出现多线程的安全问题）

- 饿汉，不存在线程安全问题

  直接创建实例，枚举类的方式，静态代码块（用来实例化更加复杂类，读取配置文件中的内容等复杂初始化逻辑）

- 懒汉，存在线程安全问题

  双重检验的方式，内部类的方式（内部类不会随着外边的类进行初始化加载，只有第一次使用的时候才被初始化，利用了初始化安全机制）。

#### 7.spring的事务传播类型和隔离机制

一个事务中调用其他事务

- REQUIRED（默认）

  官方说法：支持使用当前事务，如果当前事务不存在，创建一个新事务。

  自己的说法：外层事务为准，如果这个事务不存在，就创建一个事务

- REQUIRES_NEW

  官方：创建一个新事务，如果当前事务存在，把当前事务挂起。

  自己：最外层的事务挂起，使用当前的事务（给当前创建一个事务）

- SUPPORTS

  官方：支持使用当前事务，如果当前事务不存在，则不使用事务。

  自己：如果最外层事务不存在，里边的事务方法就不使用事务

- MANDATORY

  官方：中文翻译为强制，支持使用当前事务，如果当前事务不存在，则抛出Exception。

  自己：如果最外层事务不存在，里边的事务方法就抛出异常

- NOT_SUPPORTED

  官方：无事务执行，如果当前事务存在，把当前事务挂起。

  自己：如果最外层的事务存在，就挂起最外层的事务，不执行事务

- NEVER

  官方：无事务执行，如果当前有事务则抛出Exception。

  自己：如果最外层的事务存在，直接抛出异常

- NESTED

  官方：嵌套事务，如果当前事务存在，那么在嵌套的事务中执行。如果当前事务不存在，则表现跟REQUIRED一样。

  自己：使用被调用的方法的事务



